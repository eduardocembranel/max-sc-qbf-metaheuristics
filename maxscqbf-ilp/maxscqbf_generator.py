import sys
from typing import List
import random

import numpy as np

def generateByExactSubsetSize(name: str, n: int, subsetsSize: int, intervalBegin: int, intervalEnd: int):
    S = [set() for _ in range(n)]

    ensureUniverseCovered(n, S)
    ensureNonEmptySubsets(n, S)

    for i in range(n):
        fillSubset(S[i], n, subsetsSize)

    A = generateMatrixA(n, intervalBegin, intervalEnd)
    
    writeInstanceToFile(name, n, S, A)

def generateByNormalSubsetSize(name: str, n: int, mean: float, stddev: float, intervalBegin: int, intervalEnd: int):
    S = [set() for _ in range(n)]

    ensureUniverseCovered(n, S)
    ensureNonEmptySubsets(n, S)

    distribution = np.random.normal(loc=mean, scale=stddev, size=n)
    distribution_int = np.round(distribution).astype(int)
    distribution_clipped = np.array([1 if x < 1 else (n - 1 if x >= n else x) for x in distribution_int])
    distribution_sorted = np.sort(distribution_clipped)

    for i in range(n):
        subsetsSize = distribution_sorted[i]
        fillSubset(S[i], n, subsetsSize)

    A = generateMatrixA(n, intervalBegin, intervalEnd)
    
    writeInstanceToFile(name, n, S, A)

def generateByExpSubsetSize(name: str, n: int, lambda_: float, intervalBegin: int, intervalEnd: int):
    S = [set() for _ in range(n)]

    ensureUniverseCovered(n, S)
    ensureNonEmptySubsets(n, S)

    distribution = []
    while len(distribution) != n:
        x = int(np.random.exponential(1/lambda_))
        if x < 1:
            x = 1
        if x <= n:
            distribution.append(x)
    distribution_np = np.array(distribution)

    for i in range(n):
        subsetsSize = distribution_np[i]
        fillSubset(S[i], n, subsetsSize)

    A = generateMatrixA(n, intervalBegin, intervalEnd)
    
    writeInstanceToFile(name, n, S, A)

def ensureUniverseCovered(n: int, S: List[set[int]]):
    # the union of all subsets must cover the universe
    # to satisfy this, for each variable k, we add it to at least one subset i
    for k in range(n):
        i = random.randint(0, n - 1)
        S[i].add(k)

def ensureNonEmptySubsets(n: int, S: List[set[int]]):
    # to guaranty all subsets not being empty
    # add at least one variable for each subset
    for i in range(n):
        if len(S[i]) == 0:
            randomVar = random.randint(0, n - 1)
            S[i].add(randomVar)

def fillSubset(si: set[int], n: int, subsetSize: int):
    if len(si) >= subsetSize:
        return

    universe = set(range(n))
    candidateVars = list(universe - si)
    varsToBeAdded = random.sample(candidateVars, subsetSize - len(si))
    si.update(varsToBeAdded)
        
def generateMatrixA(n: int, intervalBegin: int, intervalEnd: int) -> List[List[int]]:
    A = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n - i):
            val = round(random.uniform(intervalBegin, intervalEnd), 2)
            A[i][i + j] = val
    return A

def writeInstanceToFile(name: str, n: int, S: List[set[int]], A: List[List[float]]):
    with open(f"instances/{name}.txt", "w") as f:
        f.write(f"{n}\n")
        for i in range(n):
            sizeSi = len(S[i])
            if i == n - 1:
                f.write(f"{sizeSi}\n")
            else:
                f.write(f"{sizeSi} ")

        for i in range(n):
            elemIdx = 0
            for elem in S[i]:
                if elemIdx == len(S[i]) - 1:
                    f.write(f"{elem + 1}\n")
                else:
                    f.write(f"{elem + 1} ")
                elemIdx += 1

        for i in range(n):
            for j in range(n - i):
                aij = A[i][i + j]
                if j == n - i - 1:
                    f.write(f"{aij}\n")
                else:
                    f.write(f"{aij} ")

def gerar_exponencial_limitada(n: int, lambda_: float):
    distribution = []
    while len(distribution) < n:
        x = np.random.exponential(1/lambda_)
        x = int(x) + 1
        if x <= n:
            distribution.append(x)

    return np.array(distribution)

def generate15Instances():
    for n in [25, 50, 100, 200, 400]:
        intervalBegin, intervalEnd = -50, 50
        if n == 100:
            intervalBegin = -30
        generateByExactSubsetSize(f"exact_n{n}", n, n//2, intervalBegin, intervalEnd)
        generateByNormalSubsetSize(f"normal_n{n}", n, n/2, (n/2)*0.20, intervalBegin, intervalEnd)
        generateByExpSubsetSize(f"exp_n{n}", n, 0.1, intervalBegin, intervalEnd)
#
# the instances generated by this function are used for testing with the bruteforce algorithm to validate the correctness
# of the ILP model by comparing the results
#
def generateSmallIntances():
    n = 15

    for i in range(10):
        generateByExactSubsetSize(f"small_{i+1}", n, n//2, -50, 50)


if __name__ == "__main__":
    seed = 2025

    random.seed(seed)
    np.random.seed(seed)

    if len(sys.argv) >= 2 and sys.argv[1] == "--type=small":
        generateSmallIntances()
    else:
        generate15Instances()